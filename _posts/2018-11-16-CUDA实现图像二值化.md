---
layout: post
title: "CUDA实现图像二值化"
date: 2018-11-16
categories:
- DeltaCV
tag:
- CUDA
- DeltaCV
- 二值化
---

着重介绍了阈值二值化及ostu二值化的实现，算法本身很简单，主要是将算法并行化，有点费事，同时也注意到了算法的时序性较强的算法，cuda移植后性能并不会得到大幅度提升，提升往往在10倍左右，值得深思。

### 阈值二值化
阈值二值化，这里是指阈值是人为设定的，简单的二值化，鲁棒性低，计算量小。
```cpp
/*
 * Compare 'threshold()' funciton in OpenCV
 * When:
 *      thresholdMin = thresholdMax and valMin = 0  ==> THRESH_BINARY
 *      thresholdMin = thresholdMax and valMax = 0  ==> THRESH_BINARY_INV
 *      thresholdMax = valMax and thresholdMin = 0  ==> THRESH_TRUNC
 *      thresholdMax = 255 and valMin = 0  ==> THRESH_TOZERO
 *      thresholdMin = 0 and valMax = 0  ==> THRESH_TOZERO_INV
 */

__global__ void thresholdBinarization(unsigned char* dataIn,
                                      unsigned char* dataOut,
                                      short int imgRows,
                                      short int imgCols,
                                      unsigned char thresholdMin,
                                      unsigned char thresholdMax,
                                      unsigned char valMin,
                                      unsigned char valMax)
{
    int xIndex = threadIdx.x + __umul24(blockIdx.x, blockDim.x);
    int yIndex = threadIdx.y + __umul24(blockIdx.y, blockDim.y);

    int tid = __umul24(yIndex,imgCols)+xIndex;

    unsigned char val=dataIn[tid];
    unsigned char res = val;

    if(xIndex < imgCols && yIndex < imgRows)
    {

        if(val>thresholdMax)
        {
            res = valMax;
        }

        if(val<=thresholdMin)
        {
            res = valMin;
        }

        dataOut[tid] = res;
    }
}
```
这个算法非常简单，设置与图像像素数一样的thread，thread读取每个像素值，直接进行判断，这里使用分支语句的影响很小，貌似可以被编译器优化，不必太担心效率。
而且通过适当的参数设置（见代码中的注释部分），可以得到与opencv中threshold函数一样的效果。

### ostu二值化

ostu又称为自适应阈值二值化，它的主要思想是假设出背景和前景，如果当前的阈值使两个的类间方差最大，则说明此时的阈值是最优的。详细的思路为：
1、计算图像的**归一化直方图**，其中级数为256级（与灰度级一致），此步骤得到一个256大小的数组。
2、此步骤即进入迭代，设i为当前选取的灰度级，假定$0-i$为前景，$i-L$为背景，

